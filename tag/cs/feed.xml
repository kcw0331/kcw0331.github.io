<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="http://localhost:4000/tag/cs/feed.xml" rel="self" type="application/atom+xml" />
  <link href="http://localhost:4000/" rel="alternate" type="text/html" />
  <updated>2023-04-05T19:04:59+09:00</updated>
  <id>http://localhost:4000/tag/cs/feed.xml</id>

  
  
  

  
    <title type="html">꿈을 향해 나아가자! | </title>
  

  
    <subtitle>창우의 아이티블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">cs - Critical Section, Singleton Pattern, Overloading, Overriding</title>
      <link href="http://localhost:4000/tag/cs-2" rel="alternate" type="text/html" title="cs - Critical Section, Singleton Pattern, Overloading, Overriding" />
      <published>2023-04-05T01:40:00+09:00</published>
      <updated>2023-04-05T01:40:00+09:00</updated>
      <id>http://localhost:4000/tag/cs-2</id>
      <content type="html" xml:base="http://localhost:4000/tag/cs-2">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;CS 스터디 공부 목록 &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./cs-1&quot;&gt;CS - Hyper-parameter&lt;/a&gt;&lt;/li&gt;
&lt;!--    &lt;li&gt;&lt;a href=&quot;./coding-thiscoding(20230117)&quot;&gt;Coding - 순차 탐색&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--    &lt;li&gt;&lt;a href=&quot;./coding-thiscoding(20230118)&quot;&gt;Coding - 이진 탐색&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--    &lt;li&gt;&lt;a href=&quot;./msai-1weeks(2)&quot;&gt;Msai - 1주차(2)&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--    &lt;li&gt;&lt;a href=&quot;./msai-1weeks(3)&quot;&gt;Msai - 1주차(3)&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;1-critical-section&quot;&gt;1. Critical Section&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Critical section은 멀티스레드 환경에서 공유 자원에 대한 접근이 제한되어야 하는 코드 영역을 말합니다.(= 한 순간 반드시 프로세스 하나만 집입해야 하는데, 프로그램에서 임계 자원을 이용하는 부분으로 공유 자원의 독점을 보장하는 코드 영역을 의미합니다.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;여러 스레드가 공유 자원에 동시에 접근하면 충돌이 발생하여 예기치 않은 동작이 발생할 수 있습니다. 따라서 이를 방지하기 위해서는 공유 자원을 보호하는 방법이 필요합니다. 이를 위해서 Critical section이라는 개념이 등장하게 되었습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Critical section은 한 번에 하나의 스레드만 접근할 수 있는 코드영역입니다. 이를 구현하기 위해 락(lock)이라는 동기화 기술을 사용합니다. 락은 공유 자원에 대한 접근 권한을 가진 스레으가 락을 확보하고, 작업이 끝난 후 락을 해제함으로써 다른 스레드가 접근할 수 있도록 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;락을 사용하여 Critical section을 보호하면, 멀티스레드 환경에서 안전하게 공유 자원에 접근할 수 있습니다. 하지만 락이 잘못 사용될 경우, 데드락(Deadlock)이 발생하거나 성능 저하가 일어날 수 있으므로 주의해야 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;임계 구역은 지정된 시간이 지난 후 종료된다.&lt;/strong&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;공유되는 자원 =&amp;gt; 동시에 접근하려고 하는 자원에서 문제가 생기지 않게 보장해주어야 하는 영역이다.(= 임계영역)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;임계 영역을 해결하기 위한 방법&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;크리티컬 섹션 문제에 대한 모든 솔루션은 다음 요구 사항을 충족합니다.
      &lt;ol&gt;
        &lt;li&gt;상호배제: 한 프로세스가 임계 영역에 들어갔을 때, 다른 포르세스는 들어갈 수 없습니다.&lt;/li&gt;
        &lt;li&gt;진행률: 임계 구역에서 실행 중인 프로세스가 없고 임계 구역에 진입하려는 프로세스가 있을 때, 진입하기 위해 무한전 기다릴 필요는 없습니다.&lt;/li&gt;
        &lt;li&gt;제한된 대기: 다른 프로세스가 임계 영역에 들어가도록 요청한 후 해당 요청이 수락되기 전에 프로세스가 임계 영역에서 실행할 수 있는 횟수에 제한이 있어야 합니다.&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;2-singleton-pattern&quot;&gt;2. Singleton pattern&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;싱글턴 패턴을 따르는 클래스는 생성자가 여러 차례 호출 되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초의 생성자가 객체를 리턴한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이와 같은 디자인 유형을 “싱글턴 패턴”이라고 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;파이썬의 모듈은 그 자체로 싱글턴이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# 파이썬
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;singleton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;__instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__new__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__instance&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__new__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__instance&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;3-overriding-and-overloading&quot;&gt;3. Overriding And Overloading&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Overriding과 Overloading은 객체 지향 프로그램(OOP)에서 다형성을 구현하기 위해 사용되는 개념입니다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;여기에서 다형성(Polymorphism)은 객체 지향 프로그래밍에서 여러 개의 클래스가 동일한 메서드나 프로퍼티를 가지고 있을 때,
각 클래스의 인스턴스가 해당 메서드나 프로퍼티를 다르게 처리할 수 있는 것을 말합니다. 즉, 동일한 이름의 메서드나 프로퍼티가 다른 방식으로 동작할 수 있는 것입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;다형성은 상속, 추상화, 인터페이스, 오버라이딩 등의 개념들과 밀접한 관련이 있습니다. 예를 들면, 상위 클래스의 메서드를 하위 클래스에서 오버라이딩하여 다른 방식으로 동작할 수 있습니다.
이렇게 하위 클래스에서 상위 클래스의 메서드를 재정의하면, 다형성을 구현할 수 있습니다. 또한, 추상 클래스나 인터페이스를 사용하면, 다른 클래스에서 해당 추상 클래스나 인터페이스를 상속하거나 
구현하여 다형성을 구현할 수 있습니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;31-overloading&quot;&gt;3.1. Overloading&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;두 메서드가 같은 이름을 갖고 있으나 인자의 수나 자료형이 다른 경우입니다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Overloading(오버로딩)은 동일한 이름의 메서드를 매개변수의 개수나 타입 등을 다르게하여 여러 개 정의하는 것을 말합니다.
같은 이름의 메서드나 여러 개 있지만 매개변수의 타입이나 개수가 다르기 때문에 컨파일러는 메서드 호출 시 인자의 타입이나 개수에 맞는 메서드를 자동으로 선택해줍니다.
예를 들면, Print() 메서드는 매개변수의 타입에 따라 여러 버전이 오버로딩됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;아래는 자바에서 사용한 Overloading의 예제 코드입니다.
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Overloading&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;example&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;computeArea&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Circle&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;computeArea&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Circle&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Circle&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;computeArea&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Square&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;32-overriding&quot;&gt;3.2. Overriding&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;상위 클래스의 메서드와 이름과 signature가 같은 함수를 하위 클래스에 재정의 하는 것 입니다.
    &lt;ul&gt;
      &lt;li&gt;상속 관계에 있는 클래스 간에 같은 이름의 메서드를 정의하는 것 입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Overriding(오버라이딩)은 상위 클래스가 가지고 있는 메서드를 하위 클래스에 재정의하여 사용하는 것을 말하니다.
즉, 하위 클래스에서 상위 클래스의 메서드를 덮어쓰는 것입니다. 이를 통해 다형성을 구현할 수 있습니다. 예를 들면,
Animal 클래스에 있는 makeSound() 메서드를 하위 클래스인 Dog 클래스에서 오버 라이딩하여 개 울음소리를 내도록 구현할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;아래는 자바에서 사용한 Overriding의 예제 코드입니다.
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;overriding&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;example&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Shape&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;printMe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Shape&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;computeArea&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Circle&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Shape&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rad&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 개발자의 실수를 방지하기 위해 @Override(annotation) 쓰는 것을 권장&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;printMe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Circle&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;computeArea&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rad&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rad&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.15&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Ambiguous&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Shape&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;area&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;computeArea&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;area&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;Overrindg과 Overloading은 이름은 유하사지만, 서로 다른 개념이고 용도 또한 다릅니다.&lt;/li&gt;
        &lt;li&gt;Overloading은 같은 이름의 메서드를 다양한 매개변수로 정의하는 것이고,&lt;/li&gt;
        &lt;li&gt;Overriding은 상속 관계에서 부모 클래스의 메서드를 자식 클래스에서 재정의하여 사용하는 것입니다.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;참고문헌&quot;&gt;참고문헌&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://velog.io/@lovi0714/%EC%9E%84%EA%B3%84-%EC%98%81%EC%97%AD-Critical-Section&quot;&gt;임계영역_참고문헌1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.educative.io/answers/what-is-the-critical-section-problem-in-operating-systems&quot;&gt;임계영역_참고문헌2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Singleton_pattern&quot;&gt;Sigleton Pattern&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gmlwjd9405.github.io/2018/08/09/java-overloading-vs-overriding.html&quot;&gt;overring and overloading&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>kcw0331</name>
        
        
      </author>

      

      
        <category term="cs" />
      

      
        <summary type="html">CS 스터디 공부 목록 CS - Hyper-parameter</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">cs - Hyper-parameter</title>
      <link href="http://localhost:4000/tag/cs-1" rel="alternate" type="text/html" title="cs - Hyper-parameter" />
      <published>2023-03-29T01:40:00+09:00</published>
      <updated>2023-03-29T01:40:00+09:00</updated>
      <id>http://localhost:4000/tag/cs-1</id>
      <content type="html" xml:base="http://localhost:4000/tag/cs-1">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;CS 스터디 공부 목록 &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./cs-1&quot;&gt;CS - Hyper-parameter&lt;/a&gt;&lt;/li&gt;
&lt;!--    &lt;li&gt;&lt;a href=&quot;./coding-thiscoding(20230117)&quot;&gt;Coding - 순차 탐색&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--    &lt;li&gt;&lt;a href=&quot;./coding-thiscoding(20230118)&quot;&gt;Coding - 이진 탐색&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--    &lt;li&gt;&lt;a href=&quot;./msai-1weeks(2)&quot;&gt;Msai - 1주차(2)&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--    &lt;li&gt;&lt;a href=&quot;./msai-1weeks(3)&quot;&gt;Msai - 1주차(3)&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1-how-control-hyper-parameter-in-ai&quot;&gt;1. How control hyper-parameter in AI&lt;/h2&gt;
&lt;p&gt;Hyperparameters are parameters in machine learning models that are set before training and affect the learning process and the final model’s performance. Examples of hyperparameters include the learning rate, the number of hidden layers in a neural network, and the number of trees in a random forest model.&lt;/p&gt;

&lt;p&gt;Controlling hyperparameters in AI involves finding the optimal values for these hyperparameters that result in the best performance of the model. There are several techniques for hyperparameter tuning, including:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Grid Search: This technique involves manually defining a grid of hyperparameter values and testing each combination of hyperparameters to find the best performing model.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Random Search: This technique involves randomly sampling hyperparameter values within predefined ranges and testing each combination of hyperparameters to find the best performing model.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Bayesian Optimization: This technique uses a probabilistic model to predict the performance of different hyperparameter values and selects the next hyperparameter values to test based on the predictions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Genetic Algorithms: This technique uses an evolutionary approach to find the best combination of hyperparameters, where the fittest combinations are selected for further mutation and breeding.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Automated Machine Learning (AutoML): This is an automated approach to hyperparameter tuning that uses algorithms to search for the optimal combination of hyperparameters.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Overall, controlling hyperparameters in AI involves a combination of domain knowledge, trial and error, and algorithmic optimization techniques to find the best hyperparameters for the specific machine learning problem at hand.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>kcw0331</name>
        
        
      </author>

      

      
        <category term="cs" />
      

      
        <summary type="html">CS 스터디 공부 목록 CS - Hyper-parameter</summary>
      

      
      
    </entry>
  
</feed>
